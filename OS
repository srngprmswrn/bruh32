1) Positive or Negative
echo "Enter a Number"
read num
if [ $num -lt 0 ]
then
    echo "Negative"
elif [ $num -gt 0 ]
then
    echo "Positive"
else
    echo "Neither Positive Nor Negative"
fi



2) Biggest of Three Numbers
echo "Enter Num1"
read num1
echo "Enter Num2"
read num2
echo "Enter Num3"
read num3

if [ $num1 -gt $num2 ] && [ $num1 -gt $num3 ]
then
    echo $num1
elif [ $num2 -gt $num1 ] && [ $num2 -gt $num3 ]
then
    echo $num2
else
    echo "Biggest Number="$num3
fi



3) Sum of digits
echo "Enter a number"
read num

sum=0

while [ $num -gt 0 ]
do
    mod=$((num % 10))    #It will split each digits
    sum=$((sum + mod))   #Add each digit to sum
    num=$((num / 10))    #divide num by 10.
done

echo $sum




4) Sum of first n natural numbers
echo "Enter how many nos u want to : "
read n
s=0
for (( i=1;i<=n;i++ ))
do
s=`expr $s + $i`
done
echo “Sum of first $n = $s”




5) Sum of first n odd numbers
echo "Enter how many nos u want to : "
read n
s=0
for (( i=1;i<=n;i=i+2 ))
do
s=`expr $s + $i`
done
echo “Sum of odd upto $n = $s”




6) Sum of first n even numbers
echo "Enter how many nos u want to : "
read n
s=0
for (( i=2;i<=n;i=i+2 ))
do
s=`expr $s + $i`
done
echo “Sum of even upto $n = $s”





7) Sum of arrays
arr=(10 20 30 40 50)

sum=0

for i in ${arr[@]}
do
    sum=`expr $sum + $i`
done

echo $sum





8) Add two variables using functions
function add()
{
    sum=$(($1 + $2))
    echo "Sum = $sum"
}

a=10
b=20
#call the add function and pass the values
add $a $b





9) Shell scripts to compare two strings
read -p "Enter two strings: " str1 str2

if [ $str1 == $str2 ]
then
    echo "Equal"
else
    echo "Un Equal"
fi





dining philosopher
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>

sem_t room;
sem_t chopstick[5];

void * philosopher(void *);
void eat(int);
int main()
{
	int i,a[5];
	pthread_t tid[5];
	
	sem_init(&room,0,4);
	
	for(i=0;i<5;i++)
		sem_init(&chopstick[i],0,1);
		
	for(i=0;i<5;i++){
		a[i]=i;
		pthread_create(&tid[i],NULL,philosopher,(void *)&a[i]);
	}
	for(i=0;i<5;i++)
		pthread_join(tid[i],NULL);
}

void * philosopher(void * num)
{
	int phil=*(int *)num;

	sem_wait(&room);
	printf("\nPhilosopher %d has entered room",phil);
	sem_wait(&chopstick[phil]);
	sem_wait(&chopstick[(phil+1)%5]);

	eat(phil);
	sleep(2);
	printf("\nPhilosopher %d has finished eating",phil);

	sem_post(&chopstick[(phil+1)%5]);
	sem_post(&chopstick[phil]);
	sem_post(&room);
}

void eat(int phil)
{
	printf("\nPhilosopher %d is eating",phil);
}







fcfs
#include<stdio.h>
 
int main()
{
    int n,bt[20],wt[20],tat[20],avwt=0,avtat=0,i,j;
    printf("Enter total number of processes(maximum 20):");
    scanf("%d",&n);
 
    printf("\nEnter Process Burst Time\n");
    for(i=0;i<n;i++)
    {
        printf("P[%d]:",i+1);
        scanf("%d",&bt[i]);
    }
 
    wt[0]=0;    //waiting time for first process is 0
 
    //calculating waiting time
    for(i=1;i<n;i++)
    {
        wt[i]=0;
        for(j=0;j<i;j++)
            wt[i]+=bt[j];
    }
 
    printf("\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time");
 
    //calculating turnaround time
    for(i=0;i<n;i++)
    {
        tat[i]=bt[i]+wt[i];
        avwt+=wt[i];
        avtat+=tat[i];
        printf("\nP[%d]\t\t%d\t\t%d\t\t%d",i+1,bt[i],wt[i],tat[i]);
    }
 
    avwt/=i;
    avtat/=i;
    printf("\n\nAverage Waiting Time:%d",avwt);
    printf("\nAverage Turnaround Time:%d",avtat);
 
    return 0;
}






overlay 
1. 
#include<stdio.h>
#include<unistd.h>

void main() {
   execl("./hello", "./hello", (char *)0);
   printf("This wouldn't print\n");
   return;
}





2.
#include<stdio.h>
#include<unistd.h>

void main() {
   int pid;
   pid = fork();
   
   /* Child process */
   if (pid == 0) {
      printf("Child process: Running Hello World Program\n");
      execl("./hello", "./hello", (char *)0);
      printf("This wouldn't print\n");
   } else { /* Parent process */
      sleep(3);
      printf("Parent process: Running While loop Program\n");
      execl("./loop", "./loop", (char *)0);
      printf("Won't reach here\n");
   }
   return;
}






3.
#include<stdio.h>
#include<string.h>
#include<unistd.h>

void main(int argc, char *argv[0]) {
   int pid;
   int err;
   int num_times;
   char num_times_str[5];
   
   /* In no command line arguments are passed, then loop maximum count taken as 10 */
   if (argc == 1) {
      printf("Taken loop maximum as 10\n");
      num_times = 10;
      sprintf(num_times_str, "%d", num_times);
   } else {
      strcpy(num_times_str, argv[1]);
      printf("num_times_str is %s\n", num_times_str);
      
   }
   pid = fork();
   /* Child process */
   if (pid == 0) {
      printf("Child process: Running Hello World Program\n");
      err = execl("./hello", "./hello", (char *)0);
      printf("Error %d\n", err);
      perror("Execl error: ");
      printf("This wouldn't print\n");
   } else { /* Parent process */
      sleep(3);
      printf("Parent process: Running While loop Program\n");
      execl("./loop", "./loop", (char *)num_times_str, (char *)0);
      printf("Won't reach here\n");
   }
   return;
}







pipe
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/wait.h>
int main()
{
int fd[2],n;
char buffer[100];
pid_t p;
pipe(fd); //creates a unidirectional pipe with two end fd[0] and fd[1]
p=fork();
if(p>0) //parent
{
printf("Parent Passing value to child\n");
write(fd[1],"hello\n",6); //fd[1] is the write end of the pipe
wait(NULL);
}
else // child
{
printf("Child printing received value\n");
n=read(fd[0],buffer,100); //fd[0] is the read end of the pipe
write(1,buffer,n);
}
return 0;
}







priority
#include<stdio.h>
struct process
{
    int id,WT,AT,BT,TAT,PR;
};
struct process a[10];

// function for swapping
void swap(int *b,int *c)
{
    int tem;
    tem=*c;
    *c=*b;
    *b=tem;
}

//Driver function
int main()
{
    int n,check_ar=0;
    int Cmp_time=0;
    float Total_WT=0,Total_TAT=0,Avg_WT,Avg_TAT;
    printf("Enter the number of process \n");
    scanf("%d",&n);
    printf("Enter the Arrival time , Burst time and priority of the process\n");
    printf("AT BT PR\n");
    for(int i=0;i<n;i++)
    {
        scanf("%d%d%d",&a[i].AT,&a[i].BT,&a[i].PR);
        a[i].id=i+1;
        // here we are checking that arrival time 
        // of the process are same or different
        if(i==0)
         check_ar=a[i].AT;
         
        if(check_ar!=a[i].AT )
         check_ar=1;
        
    }
    // if process are arrived at the different time 
    // then sort the process on the basis of AT
    if(check_ar!=0)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n-i-1;j++)
            {
                if(a[j].AT>a[j+1].AT)
                {
                      swap(&a[j].id,&a[j+1].id);
                      swap(&a[j].AT,&a[j+1].AT);
                      swap(&a[j].BT,&a[j+1].BT);
                      swap(&a[j].PR,&a[j+1].PR);
                }
            }
        }
    }
    
    // logic of Priority scheduling ( non preemptive) algo
    // if all the process are arrived at different time
    if(check_ar!=0)
    {
        a[0].WT=a[0].AT;
        a[0].TAT=a[0].BT-a[0].AT;
        // cmp_time for completion time
        Cmp_time=a[0].TAT;
        Total_WT=Total_WT+a[0].WT;
        Total_TAT=Total_TAT+a[0].TAT;
        for(int i=1;i<n;i++)
        {
            int min=a[i].PR;
            for(int j=i+1;j<n;j++)
            {
                if(min>a[j].PR && a[j].AT<=Cmp_time)
                {
                      min=a[j].PR;
                      swap(&a[i].id,&a[j].id);
                      swap(&a[i].AT,&a[j].AT);
                      swap(&a[i].BT,&a[j].BT);
                      swap(&a[i].PR,&a[j].PR);
                      
                }
                
            }
            a[i].WT=Cmp_time-a[i].AT;
            Total_WT=Total_WT+a[i].WT;
            // completion time of the process
            Cmp_time=Cmp_time+a[i].BT;
            
            // Turn Around Time of the process
            // compl-Arival
            a[i].TAT=Cmp_time-a[i].AT;
            Total_TAT=Total_TAT+a[i].TAT;
            
        }
    }
    
    // if all the process are arrived at same time
    else
    {
        for(int i=0;i<n;i++)
        {
            int min=a[i].PR;
            for(int j=i+1;j<n;j++)
            {
                if(min>a[j].PR && a[j].AT<=Cmp_time)
                {
                    min=a[j].PR;
                      swap(&a[i].id,&a[j].id);
                      swap(&a[i].AT,&a[j].AT);
                      swap(&a[i].BT,&a[j].BT);
                       swap(&a[i].PR,&a[j].PR);
                }
                
            }
            a[i].WT=Cmp_time-a[i].AT;
            
             // completion time of the process
            Cmp_time=Cmp_time+a[i].BT;
            
            // Turn Around Time of the process
            // compl-Arrival
            a[i].TAT=Cmp_time-a[i].AT;
            Total_WT=Total_WT+a[i].WT;
            Total_TAT=Total_TAT+a[i].TAT;
            
        }
        
    }
    
    Avg_WT=Total_WT/n;
    Avg_TAT=Total_TAT/n;

    // Printing of the results
    printf("The process are\n");
    printf("ID WT TAT\n");
    for(int i=0;i<n;i++)
    {
        printf("%d\t%d\t%d\n",a[i].id,a[i].WT,a[i].TAT);
    }
    
    printf("Avg waiting time is: %f\n",Avg_WT);
    printf("Avg turn around time is: %f",Avg_TAT);
    return 0;
}







priority2
#include <stdio.h>

void main()
{
    int pn = 0;                 //Processes Number
    int CPU = 0;            //CPU Current time
    int allTime = 0;        // Time neded to finish all processes
    printf("Enrer Processes Count: ");
    scanf("%d",&pn);
    int AT[pn];
    int ATt[pn];
    int NoP = pn;
    int PT[pn];             //Processes Time
    int PP[pn];             //Processes piriorty
    int waittingTime[pn];
    int turnaroundTime[pn];
    
    //Scanning Time and Piriorty
    for(int i=0 ;i<pn ;i++){
        printf("\nProcessing time for P%d: ",i+1);
        scanf("%d",&PT[i]);
        printf("Piriorty for P%d: ",i+1);
        scanf("%d",&PP[i]);
        printf("Arrival Time for P%d: ",i+1);
        scanf("%d",&AT[i]);
        ATt[i] = AT[i];
    }
    

    
    
    int LAT = 0;        //LastArrivalTime
    for(int i = 0; i < pn; i++)
        if(AT[i] > LAT)
            LAT = AT[i];
            
    int ATv = AT[0];    //Pointing to Arrival Time Value
    int ATi = 0;        //Pointing to Arrival Time indix
    int P1 = PP[0];     //Pointing to 1st piriorty Value
    int P2 = PP[0];     //Pointing to 2nd piriorty Value
   
    
    //findding the First Arrival Time and Highst piriorty Process
   
    while(NoP > 0 && CPU <= 1000){
        for(int i = 0; i < pn; i++){
            if(ATt[i] < ATv){
                ATi = i;
                ATv = ATt[i];
                P1 = PP[i];
                P2 = PP[i];
            }
            else if(ATt[i] == ATv || ATt[i] <= CPU){
                if(PP[i] != (pn+1))
                    P2 = PP[i];
                    if(P2 < P1){
                        ATi = i;
                        ATv = ATt[i];
                        P1 = PP[i];
                        P2 = PP[i];
                    }
            }
        }
        if(CPU < ATv){
            CPU = CPU+1;
            continue;
        }else{
            
           
            waittingTime[ATi] = CPU - ATt[ATi];
            CPU = CPU + PT[ATi];
            turnaroundTime[ATi] = CPU - ATt[ATi];
            ATt[ATi] = LAT +10;
            ATv = LAT +10;  //Pointing to Arrival Time Value
            ATi = 0;        //Pointing to Arrival Time indix
            PP[ATi] = pn + 1;
            P1 = PP[0];     //Pointing to 1st piriorty Value
            P2 = PP[0];     //Pointing to 2nd piriorty Value
            NoP = NoP - 1;
           
        }
        
        
        
        
    }
    
    
    
    printf("\nPN\tPT\tPP\tWT\tTT\n\n");
    for(int i = 0; i < pn; i++){
       printf("P%d\t%d\t%d\t%d\t%d\n",i+1,PT[i],PP[i],waittingTime[i],turnaroundTime[i]);
    }
   
    int AvgWT = 0;
    int AVGTaT = 0;
    for(int i = 0; i < pn; i++){
        AvgWT = waittingTime[i] + AvgWT;
        AVGTaT = turnaroundTime[i] + AVGTaT;
    }
   
   
   printf("AvgWaittingTime = %d\nAvgTurnaroundTime = %d\n",AvgWT/pn,AVGTaT/pn);
}







writer(reader)
//g++ -pthread readwrite.cpp -o readwrite
//./readwrite

#include <iostream>
#include <pthread.h>
#include <unistd.h>
using namespace std;

class monitor {
private:
	// no. of readers
	int rcnt;

	// no. of writers
	int wcnt;

	// no. of readers waiting
	int waitr;

	// no. of writers waiting
	int waitw;

	// condition variable to check whether reader can read
	pthread_cond_t canread;

	// condition variable to check whether writer can write
	pthread_cond_t canwrite;

	// mutex for synchronisation
	pthread_mutex_t condlock;

public:
	monitor()
	{
		rcnt = 0;
		wcnt = 0;
		waitr = 0;
		waitw = 0;

		pthread_cond_init(&canread, NULL);
		pthread_cond_init(&canwrite, NULL);
		pthread_mutex_init(&condlock, NULL);
	}

	// mutex provide synchronisation so that no other thread
	// can change the value of data
	void beginread(int i)
	{
		pthread_mutex_lock(&condlock);

		// if there are active or waiting writers
		if (wcnt == 1 || waitw > 0) {
			// incrementing waiting readers
			waitr++;

			// reader suspended
			pthread_cond_wait(&canread, &condlock);
			waitr--;
		}

		// else reader reads the resource
		rcnt++;
		cout << "reader " << i << " is reading\n";
		pthread_mutex_unlock(&condlock);
		pthread_cond_broadcast(&canread);
	}

	void endread(int i)
	{

		// if there are no readers left then writer enters monitor
		pthread_mutex_lock(&condlock);

		if (--rcnt == 0)
			pthread_cond_signal(&canwrite);

		pthread_mutex_unlock(&condlock);
	}

	void beginwrite(int i)
	{
		pthread_mutex_lock(&condlock);

		// a writer can enter when there are no active
		// or waiting readers or other writer
		if (wcnt == 1 || rcnt > 0) {
			++waitw;
			pthread_cond_wait(&canwrite, &condlock);
			--waitw;
		}
		wcnt = 1;
		cout << "writer " << i << " is writing\n";
		pthread_mutex_unlock(&condlock);
	}

	void endwrite(int i)
	{
		pthread_mutex_lock(&condlock);
		wcnt = 0;

		// if any readers are waiting, threads are unblocked
		if (waitr > 0)
			pthread_cond_signal(&canread);
		else
			pthread_cond_signal(&canwrite);
		pthread_mutex_unlock(&condlock);
	}

}

// global object of monitor class
M;

void* reader(void* id)
{
	int c = 0;
	int i = *(int*)id;

	// each reader attempts to read 5 times
	while (c < 5) {
		usleep(1);
		M.beginread(i);
		M.endread(i);
		c++;
	}
	return id;
}

void* writer(void* id)
{
	int c = 0;
	int i = *(int*)id;

	// each writer attempts to write 5 times
	while (c < 5) {
		usleep(1);
		M.beginwrite(i);
		M.endwrite(i);
		c++;
	}
	return id; 
}

int main()
{
	pthread_t r[5], w[5];
	int id[5];
	for (int i = 0; i < 5; i++) {
		id[i] = i;

		// creating threads which execute reader function
		pthread_create(&r[i], NULL, &reader, &id[i]);

		// creating threads which execute writer function
		pthread_create(&w[i], NULL, &writer, &id[i]);
	}

	for (int i = 0; i < 5; i++) {
		pthread_join(r[i], NULL);
	}
	for (int i = 0; i < 5; i++) {
		pthread_join(w[i], NULL);
	}
}









reader
#include <iostream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
using namespace std;
int main(){
	key_t key = ftok("shmfile",65);
	int shmid = shmget( key , 1024 , 0666 | IPC_CREAT );
	char *str = ( char* ) shmat( shmid,( void* ) , 0 , 0 );
	printf( " Data read from memory: %s \n " , str );
	shmdt ( str ) ;
	shmctl ( shmid , IPC_RMID , NULL ) ;
	return 0;}









writing(shared)
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/shm.h>
#include <string.h>
int main()
{
	int i;
	void *shared_memory;
	char buff[100];
	int shmid;
	shmid=shmget((key_t)2345, 1024, 0666|IPC_CREAT);
	printf("Key of shared memory is %d\n",shmid);
	shared_memory=shmat(shmid,NULL,0);
	printf("Process attached at %p\n",shared_memory);
	printf("Enter some data to write to shared memory\n");
	read(0,buff,100);
	strcpy(shared_memory,buff);
	printf("You wrote: %s\n", (char *)shared_memory);
}







reading(shared)
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/shm.h>
#include <string.h>
int main()
{
	int i;
	void *shared_memory;
	char buff[100];
	int shmid;
	shmid=shmget((key_t)2345, 1024, 0666);
	printf("Key of shared memory is %d\n", shmid);
	shared_memory=shmat(shmid,NULL,0);
	printf("Process attached at %p\n", shared_memory);
	printf("Data read from shared memory is: %s\n", (char *)shared_memory);
}









roundrobin c
#include<stdio.h>
 
int main()
{
 
  int count,j,n,time,remain,flag=0,time_quantum;
  int wait_time=0,turnaround_time=0,at[10],bt[10],rt[10];
  printf("Enter Total Process:\t ");
  scanf("%d",&n);
  remain=n;
  for(count=0;count<n;count++)
  {
    printf("Enter Arrival Time and Burst Time for Process Process Number %d :",count+1);
    scanf("%d",&at[count]);
    scanf("%d",&bt[count]);
    rt[count]=bt[count];
  }
  printf("Enter Time Quantum:\t");
  scanf("%d",&time_quantum);
  printf("\n\nProcess\t|Turnaround Time|Waiting Time\n\n");
  for(time=0,count=0;remain!=0;)
  {
    if(rt[count]<=time_quantum && rt[count]>0)
    {
      time+=rt[count];
      rt[count]=0;
      flag=1;
    }
    else if(rt[count]>0)
    {
      rt[count]-=time_quantum;
      time+=time_quantum;
    }
    if(rt[count]==0 && flag==1)
    {
      remain--;
      printf("P[%d]\t|\t%d\t|\t%d\n",count+1,time-at[count],time-at[count]-bt[count]);
      wait_time+=time-at[count]-bt[count];
      turnaround_time+=time-at[count];
      flag=0;
    }
    if(count==n-1)
      count=0;
    else if(at[count+1]<=time)
      count++;
    else
      count=0;
  }
  printf("\nAverage Waiting Time= %f\n",wait_time*1.0/n);
  printf("Avg Turnaround Time = %f",turnaround_time*1.0/n);
  
  return 0;
}








roundrobin cpp
#include<iostream>
using namespace std;

// Function to find the waiting time for all
// processes
void findWaitingTime(int processes[], int n,
			int bt[], int wt[], int quantum)
{
	// Make a copy of burst times bt[] to store remaining
	// burst times.
	int rem_bt[n];
	for (int i = 0 ; i < n ; i++)
		rem_bt[i] = bt[i];

	int t = 0; // Current time

	// Keep traversing processes in round robin manner
	// until all of them are not done.
	while (1)
	{
		bool done = true;

		// Traverse all processes one by one repeatedly
		for (int i = 0 ; i < n; i++)
		{
			// If burst time of a process is greater than 0
			// then only need to process further
			if (rem_bt[i] > 0)
			{
				done = false; // There is a pending process

				if (rem_bt[i] > quantum)
				{
					// Increase the value of t i.e. shows
					// how much time a process has been processed
					t += quantum;

					// Decrease the burst_time of current process
					// by quantum
					rem_bt[i] -= quantum;
				}

				// If burst time is smaller than or equal to
				// quantum. Last cycle for this process
				else
				{
					// Increase the value of t i.e. shows
					// how much time a process has been processed
					t = t + rem_bt[i];

					// Waiting time is current time minus time
					// used by this process
					wt[i] = t - bt[i];

					// As the process gets fully executed
					// make its remaining burst time = 0
					rem_bt[i] = 0;
				}
			}
		}

		// If all processes are done
		if (done == true)
		break;
	}
}

// Function to calculate turn around time
void findTurnAroundTime(int processes[], int n,
						int bt[], int wt[], int tat[])
{
	// calculating turnaround time by adding
	// bt[i] + wt[i]
	for (int i = 0; i < n ; i++)
		tat[i] = bt[i] + wt[i];
}

// Function to calculate average time
void findavgTime(int processes[], int n, int bt[],
									int quantum)
{
	int wt[n], tat[n], total_wt = 0, total_tat = 0;

	// Function to find waiting time of all processes
	findWaitingTime(processes, n, bt, wt, quantum);

	// Function to find turn around time for all processes
	findTurnAroundTime(processes, n, bt, wt, tat);

	// Display processes along with all details
	cout << "Processes "<< " Burst time "
		<< " Waiting time " << " Turn around time\n";

	// Calculate total waiting time and total turn
	// around time
	for (int i=0; i<n; i++)
	{
		total_wt = total_wt + wt[i];
		total_tat = total_tat + tat[i];
		cout << " " << i+1 << "\t\t" << bt[i] <<"\t "
			<< wt[i] <<"\t\t " << tat[i] <<endl;
	}

	cout << "Average waiting time = "
		<< (float)total_wt / (float)n;
	cout << "\nAverage turn around time = "
		<< (float)total_tat / (float)n;
}

// Driver code
int main()
{
	// process id's
	int processes[] = { 1, 2, 3};
	int n = sizeof processes / sizeof processes[0];

	// Burst time of all processes
	int burst_time[] = {10, 5, 8};

	// Time quantum
	int quantum = 2;
	findavgTime(processes, n, burst_time, quantum);
	return 0;
}








semaphore
// C program to demonstrate working of Semaphores
// gcc semaphore.c -o semaphore -lpthread -lrt
// ./semaphore


#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

sem_t mutex;

void* thread(void* arg)
{
	//wait
	sem_wait(&mutex);
	printf("\nEntered..\n");

	//critical section
	sleep(4);
	
	//signal
	printf("\nJust Exiting...\n");
	sem_post(&mutex);
	return arg;
}
int main()
{
	sem_init(&mutex, 0, 1);
	pthread_t t1,t2;
	pthread_create(&t1,NULL,thread,NULL);
	sleep(2);
	pthread_create(&t2,NULL,thread,NULL);
	pthread_join(t1,NULL);
	pthread_join(t2,NULL);
	sem_destroy(&mutex);
	return 0;
}







sjf
#include<stdio.h>
 int main()
{
    int bt[20],p[20],wt[20],tat[20],i,j,n,total=0,pos,temp;
    float avg_wt,avg_tat;
    printf("Enter number of process:");
    scanf("%d",&n);
    printf("\nEnter Burst Time:\n");
    for(i=0;i<n;i++)
    {
        printf("p%d:",i+1);
        scanf("%d",&bt[i]);
        p[i]=i+1;         
    }
   //sorting of burst times
    for(i=0;i<n;i++)
    {
        pos=i;
        for(j=i+1;j<n;j++)
        {
            if(bt[j]<bt[pos])
                pos=j;
        }
        temp=bt[i];
        bt[i]=bt[pos];
        bt[pos]=temp;
        temp=p[i];
        p[i]=p[pos];
        p[pos]=temp;
    }
    wt[0]=0;            
    for(i=1;i<n;i++)
    {
        wt[i]=0;
        for(j=0;j<i;j++)
            wt[i]+=bt[j];
        total+=wt[i];
    }
    avg_wt=(float)total/n;      
    total=0;
    printf("\nProcess\t    Burst Time    \tWaiting Time\tTurnaround Time");
    for(i=0;i<n;i++)
    {
        tat[i]=bt[i]+wt[i];   
        total+=tat[i];
        printf("\np%d\t\t  %d\t\t    %d\t\t\t%d",p[i],bt[i],wt[i],tat[i]);
    }
    avg_tat=(float)total/n;    
    printf("\n\nAverage Waiting Time=%f",avg_wt);
    printf("\nAverage Turnaround Time=%f\n",avg_tat);
}
